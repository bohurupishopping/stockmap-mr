import 'package:flutter/material.dart';
import '../models/product_models.dart';
import '../services/product_service.dart';
import '../widgets/product_filters_widget.dart';
import '../widgets/product_card.dart';
import '../widgets/product_details_dialog.dart';

class ProductPage extends StatefulWidget {
  const ProductPage({super.key});

  @override
  State<ProductPage> createState() => _ProductPageState();
}

class _ProductPageState extends State<ProductPage> {
  static const int itemsPerPage = 20;

  ProductFilters _filters = ProductFilters();
  int _currentPage = 1;
  List<Product> _products = [];
  bool _isLoading = false;
  bool _hasMoreData = true;
  int _totalCount = 0;
  
  // Filter data
  List<ProductCategory> _categories = [];
  List<ProductSubCategory> _subCategories = [];
  List<ProductFormulation> _formulations = [];
  List<String> _manufacturers = [];
  
  String _sortField = 'product_name';
  String _sortDirection = 'asc';
  
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _loadInitialData();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      _loadMoreProducts();
    }
  }

  Future<void> _loadInitialData() async {
    setState(() {
      _isLoading = true;
    });

    try {
      // Load filter data and initial products in parallel
      final futures = await Future.wait([
        ProductService.getCategories(),
        ProductService.getFormulations(),
        ProductService.getManufacturers(),
        ProductService.getProducts(
          filters: _filters,
          sortField: _sortField,
          sortDirection: _sortDirection,
          limit: itemsPerPage,
          offset: 0,
        ),
        ProductService.getProductsCount(filters: _filters),
      ]);

      _categories = futures[0] as List<ProductCategory>;
      _formulations = futures[1] as List<ProductFormulation>;
      _manufacturers = futures[2] as List<String>;
      _products = futures[3] as List<Product>;
      _totalCount = futures[4] as int;
      
      // Load sub-categories for all categories
      _subCategories = [];
      for (final category in _categories) {
        final subCats = await ProductService.getSubCategories(category.id);
        _subCategories.addAll(subCats);
      }
      
      _hasMoreData = _products.length < _totalCount;
      _currentPage = 1;
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading data: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _refreshProducts() async {
    setState(() {
      _isLoading = true;
      _currentPage = 1;
      _hasMoreData = true;
    });

    try {
      final futures = await Future.wait([
        ProductService.getProducts(
          filters: _filters,
          sortField: _sortField,
          sortDirection: _sortDirection,
          limit: itemsPerPage,
          offset: 0,
        ),
        ProductService.getProductsCount(filters: _filters),
      ]);

      _products = futures[0] as List<Product>;
      _totalCount = futures[1] as int;
      _hasMoreData = _products.length < _totalCount;
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading products: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _loadMoreProducts() async {
    if (_isLoading || !_hasMoreData) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final newProducts = await ProductService.getProducts(
        filters: _filters,
        sortField: _sortField,
        sortDirection: _sortDirection,
        limit: itemsPerPage,
        offset: _currentPage * itemsPerPage,
      );

      setState(() {
        _products.addAll(newProducts);
        _currentPage++;
        _hasMoreData = newProducts.length == itemsPerPage;
      });
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading more products: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  void _updateFilters(ProductFilters newFilters) {
    setState(() {
      _filters = newFilters;
    });
    _refreshProducts();
  }

  void _clearFilters() {
    setState(() {
      _filters = ProductFilters();
    });
    _refreshProducts();
  }

  void _handleSort(String field) {
    setState(() {
      if (_sortField == field) {
        _sortDirection = _sortDirection == 'asc' ? 'desc' : 'asc';
      } else {
        _sortField = field;
        _sortDirection = 'asc';
      }
    });
    _refreshProducts();
  }

  void _showProductDetails(Product product) {
    showDialog(
      context: context,
      barrierDismissible: true,
      builder: (context) => ProductDetailsDialog(product: product),
    );
  }

  void _showSortOptions() {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => Container(
        padding: const EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Sort Products',
              style: TextStyle(
                fontFamily: 'Poppins',
                fontSize: 18,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 16),
            _buildSortOption('Product Name', 'product_name'),
            _buildSortOption('Product Code', 'product_code'),
            _buildSortOption('Manufacturer', 'manufacturer'),
            _buildSortOption('Category', 'category_id'),
            _buildSortOption('Cost', 'base_cost_per_strip'),
            _buildSortOption('Created Date', 'created_at'),
          ],
        ),
      ),
    );
  }

  Widget _buildSortOption(String label, String field) {
    final isSelected = _sortField == field;
    return ListTile(
      title: Text(
        label,
        style: TextStyle(
          fontFamily: 'Poppins',
          fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
          color: isSelected ? const Color(0xFF4F46E5) : null,
        ),
      ),
      trailing: isSelected
          ? Icon(
              _sortDirection == 'asc'
                  ? Icons.arrow_upward_rounded
                  : Icons.arrow_downward_rounded,
              color: const Color(0xFF4F46E5),
            )
          : null,
      onTap: () {
        Navigator.of(context).pop();
        _handleSort(field);
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    const primaryColor = Color(0xFF4F46E5);
    

    return Scaffold(
      
      appBar: AppBar(
        backgroundColor: primaryColor,
        elevation: 0,
        title: const Text(
          'Products',
          style: TextStyle(
            fontFamily: 'Poppins',
            fontWeight: FontWeight.w600,
            color: Colors.white,
            fontSize: 20,
          ),
        ),
        centerTitle: true,
        actions: [
          IconButton(
            onPressed: _showSortOptions,
            icon: const Icon(
              Icons.sort_rounded,
              color: Colors.white,
            ),
            tooltip: 'Sort products',
          ),
          IconButton(
            onPressed: _refreshProducts,
            icon: const Icon(
              Icons.refresh_rounded,
              color: Colors.white,
            ),
            tooltip: 'Refresh',
          ),
        ],
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(bottom: Radius.circular(20)),
        ),
        automaticallyImplyLeading: false,
      ),
      body: SafeArea(
        child: Column(
          children: [
           
            // Content Section
            Expanded(
              child: Column(
                children: [
                  // Filters
                  Container(
                    margin: const EdgeInsets.only(left: 16, right: 16, bottom: 16),
                    child: ProductFiltersWidget(
                      filters: _filters,
                      categories: _categories,
                      subCategories: _subCategories,
                      formulations: _formulations,
                      manufacturers: _manufacturers,
                      onFiltersChanged: _updateFilters,
                      onClearFilters: _clearFilters,
                    ),
                  ),


                  // Products Grid
                  Expanded(
                    child: _isLoading && _products.isEmpty
                        ? const Center(
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                CircularProgressIndicator(),
                                SizedBox(height: 16),
                                Text(
                                  'Loading products...',
                                  style: TextStyle(
                                    fontFamily: 'Poppins',
                                    color: Color(0xFF6B7280),
                                  ),
                                ),
                              ],
                            ),
                          )
                        : _products.isEmpty
                            ? Center(
                                child: Column(
                                  mainAxisAlignment: MainAxisAlignment.center,
                                  children: [
                                    Icon(
                                      Icons.inventory_2_outlined,
                                      size: 64,
                                      color: Colors.grey.shade400,
                                    ),
                                    const SizedBox(height: 16),
                                    Text(
                                      'No products found',
                                      style: TextStyle(
                                        fontFamily: 'Poppins',
                                        fontSize: 18,
                                        fontWeight: FontWeight.w600,
                                        color: Colors.grey.shade600,
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    Text(
                                      'Try adjusting your filters or search terms',
                                      style: TextStyle(
                                        fontFamily: 'Poppins',
                                        color: Colors.grey.shade500,
                                      ),
                                    ),
                                  ],
                                ),
                              )
                            : Padding(
                                padding: const EdgeInsets.symmetric(horizontal: 16),
                                child: GridView.builder(
                                  controller: _scrollController,
                                  padding: const EdgeInsets.only(bottom: 16),
                                  gridDelegate:
                                      const SliverGridDelegateWithFixedCrossAxisCount(
                                    crossAxisCount: 2,
                                    crossAxisSpacing: 12,
                                    mainAxisSpacing: 12,
                                    childAspectRatio: 0.75,
                                  ),
                                  itemCount: _products.length + (_hasMoreData ? 1 : 0),
                                  itemBuilder: (context, index) {
                                    if (index >= _products.length) {
                                      return const Center(
                                        child: Padding(
                                          padding: EdgeInsets.all(16),
                                          child: CircularProgressIndicator(),
                                        ),
                                      );
                                    }

                                    final product = _products[index];
                                    return ProductCard(
                                      product: product,
                                      onTap: () => _showProductDetails(product),
                                    );
                                  },
                                ),
                              ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

}