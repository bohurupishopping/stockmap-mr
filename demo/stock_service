import 'package:supabase_flutter/supabase_flutter.dart';
import '../config/supabase_config.dart';
import '../models/stock_models.dart';

class StockService {
  static final SupabaseClient _supabase = SupabaseConfig.client;

  /// Get stock transactions for a specific product
  static Future<List<Transaction>> getProductTransactions(String productId, {int? limit}) async {
    try {
      dynamic query = _supabase
          .from('stock_transactions_view')
          .select('''
            product_id,
            batch_id,
            transaction_type,
            quantity_strips,
            location_type_source,
            location_id_source,
            location_type_destination,
            location_id_destination,
            cost_per_strip_at_transaction,
            transaction_date
          ''')
          .eq('product_id', productId)
          .order('transaction_date', ascending: false);

      if (limit != null) {
        query = query.limit(limit);
      }

      final response = await query;
      return (response as List)
          .map((transaction) => Transaction.fromJson(transaction))
          .toList();
    } catch (e) {
      throw Exception('Failed to fetch product transactions: $e');
    }
  }

  /// Get current stock for a specific product
  static Future<List<StockItem>> getProductStock(String productId) async {
    try {
      // Use productId filter for exact matching
      final filters = StockFilters(productId: productId);
      final stockItems = await calculateStockData(filters);
      return stockItems;
    } catch (e) {
      throw Exception('Failed to fetch product stock: $e');
    }
  }

  /// Get product batches with expiry information
  static Future<List<Batch>> getProductBatches(String productId) async {
    try {
      final response = await _supabase
          .from('product_batches')
          .select('id, batch_number, expiry_date, product_id')
          .eq('product_id', productId)
          .order('expiry_date');

      return (response as List)
          .map((batch) => Batch.fromJson(batch))
          .toList();
    } catch (e) {
      throw Exception('Failed to fetch product batches: $e');
    }
  }

  /// Get comprehensive product stock summary
  static Future<Map<String, dynamic>> getProductStockSummary(String productId) async {
    try {
      final futures = await Future.wait([
        getProductTransactions(productId, limit: 50),
        getProductStock(productId),
        getProductBatches(productId),
      ]);

      final transactions = futures[0] as List<Transaction>;
      final stockItems = futures[1] as List<StockItem>;
      final batches = futures[2] as List<Batch>;

      final totalGodownStock = stockItems
          .where((item) => item.locationType == 'GODOWN')
          .fold(0, (sum, item) => sum + item.currentQuantityStrips);

      final totalMrStock = stockItems
          .where((item) => item.locationType == 'MR')
          .fold(0, (sum, item) => sum + item.currentQuantityStrips);

      final totalValue = stockItems
          .fold(0.0, (sum, item) => sum + item.totalValue);

      return {
        'transactions': transactions,
        'stockItems': stockItems,
        'batches': batches,
        'totalGodownStock': totalGodownStock,
        'totalMrStock': totalMrStock,
        'totalStock': totalGodownStock + totalMrStock,
        'totalValue': totalValue,
        'batchCount': batches.length,
      };
    } catch (e) {
      throw Exception('Failed to fetch product stock summary: $e');
    }
  }

  /// Calculates stock data based on transactions and filters
  static Future<List<StockItem>> calculateStockData(StockFilters filters) async {
    try {
      // First, fetch all products for later lookup
      final productsResponse = await _supabase
          .from('products')
          .select('''
            id,
            product_name,
            product_code,
            generic_name,
            min_stock_level_godown,
            min_stock_level_mr,
            product_categories (
              category_name
            )
          ''');

      final products = (productsResponse as List)
          .map((product) => Product.fromJson(product))
          .toList();

      // Create a map of products for quick lookup
      final productMap = <String, Product>{};
      for (final product in products) {
        productMap[product.id] = product;
      }

      // Fetch all batches for later lookup
      final batchesResponse = await _supabase
          .from('product_batches')
          .select('''
            id,
            batch_number,
            expiry_date
          ''');

      final batches = (batchesResponse as List)
          .map((batch) => Batch.fromJson(batch))
          .toList();

      // Create a map of batches for quick lookup
      final batchMap = <String, Batch>{};
      for (final batch in batches) {
        batchMap[batch.id] = batch;
      }

      // Build query for transactions
      var query = _supabase
          .from('stock_transactions_view')
          .select('''
            product_id,
            batch_id,
            transaction_type,
            quantity_strips,
            location_type_source,
            location_id_source,
            location_type_destination,
            location_id_destination,
            cost_per_strip_at_transaction,
            transaction_date
          ''');

      // Apply filters
      if (filters.productId != null && filters.productId!.isNotEmpty) {
        // Filter by exact product ID
        query = query.eq('product_id', filters.productId!);
      } else if (filters.productName != null && filters.productName!.isNotEmpty) {
        // Get product IDs that match the filter
        final filteredProductIds = products
            .where((p) =>
                p.productName.toLowerCase().contains(filters.productName!.toLowerCase()) ||
                p.productCode.toLowerCase().contains(filters.productName!.toLowerCase()))
            .map((p) => p.id)
            .toList();

        if (filteredProductIds.isNotEmpty) {
          query = query.inFilter('product_id', filteredProductIds);
        } else {
          // No products match the filter, return empty result
          return [];
        }
      }

      if (filters.batchNumber != null && filters.batchNumber!.isNotEmpty) {
        // Get batch IDs that match the filter
        final filteredBatchIds = batches
            .where((b) => b.batchNumber.toLowerCase().contains(filters.batchNumber!.toLowerCase()))
            .map((b) => b.id)
            .toList();

        if (filteredBatchIds.isNotEmpty) {
          query = query.inFilter('batch_id', filteredBatchIds);
        } else {
          // No batches match the filter, return empty result
          return [];
        }
      }

      if (filters.expiryDateFrom != null && filters.expiryDateTo != null) {
        // Get batch IDs that match the expiry date range
        final fromDate = filters.expiryDateFrom!;
        final toDate = filters.expiryDateTo!;
        final filteredBatchIds = batches
            .where((b) {
              return b.expiryDate.isAfter(fromDate.subtract(const Duration(days: 1))) &&
                     b.expiryDate.isBefore(toDate.add(const Duration(days: 1)));
            })
            .map((b) => b.id)
            .toList();

        if (filteredBatchIds.isNotEmpty) {
          query = query.inFilter('batch_id', filteredBatchIds);
        } else {
          // No batches match the filter, return empty result
          return [];
        }
      }

      final transactionsResponse = await query;
      final transactions = (transactionsResponse as List)
          .map((transaction) => Transaction.fromJson(transaction))
          .toList();

      // Apply category filter if needed
      var filteredData = transactions;
      if (filters.categoryId != null && filters.categoryId!.isNotEmpty && filters.categoryId != 'ALL') {
        filteredData = filteredData.where((tx) {
          final product = productMap[tx.productId];
          if (product == null || product.productCategories == null) return false;

          return product.productCategories!
              .any((cat) => cat.categoryName == filters.categoryId);
        }).toList();
      }

      // Calculate actual stock by processing all transactions
      final stockMap = <String, StockItem>{};

      for (final transaction in filteredData) {
        try {
          // Get product and batch data from our maps
          final product = productMap[transaction.productId];
          final batch = batchMap[transaction.batchId];

          // Skip transactions with missing related data
          if (product == null || batch == null) {
            continue;
          }

          // Process transaction based on type
          _processTransaction(
            transaction,
            product,
            batch,
            stockMap,
            filters.location ?? 'ALL',
          );
        } catch (err) {
        }
      }

      // Calculate total value and filter out zero/negative stock items
      final stockItems = stockMap.values
          .where((item) => item.currentQuantityStrips > 0)
          .map((item) => StockItem(
                productId: item.productId,
                productName: item.productName,
                productCode: item.productCode,
                genericName: item.genericName,
                batchId: item.batchId,
                batchNumber: item.batchNumber,
                expiryDate: item.expiryDate,
                locationType: item.locationType,
                locationId: item.locationId,
                currentQuantityStrips: item.currentQuantityStrips,
                costPerStrip: item.costPerStrip,
                totalValue: item.currentQuantityStrips * item.costPerStrip,
                categoryName: item.categoryName,
                minStockLevelGodown: item.minStockLevelGodown,
                minStockLevelMr: item.minStockLevelMr,
              ))
          .toList();

      return stockItems;
    } catch (error) {
      rethrow;
    }
  }

  /// Processes a single transaction and updates stock accordingly
  static void _processTransaction(
    Transaction transaction,
    Product product,
    Batch batch,
    Map<String, StockItem> stockMap,
    String locationFilter,
  ) {
    final txType = transaction.transactionType;

    // Determine the location for stock movement
    String? stockLocation;
    String? stockLocationId;

    // Process based on transaction type to determine the correct stock location
    if (txType == 'STOCK_IN_GODOWN') {
      // Stock coming into godown
      stockLocation = 'GODOWN';
      stockLocationId = '';
    } else if (txType == 'DISPATCH_TO_MR') {
      // For dispatch, we have two effects:
      // 1. Decrease in godown stock (quantity_strips will be negative in DB)
      if (transaction.locationTypeSource == 'GODOWN') {
        // Only process if we're interested in godown or all locations
        if (locationFilter == 'ALL' || locationFilter == 'GODOWN') {
          final godownItem = _getOrCreateStockItem(
            transaction.productId,
            transaction.batchId,
            'GODOWN',
            '',
            product,
            batch,
            stockMap,
            transaction.costPerStripAtTransaction,
          );
          // Use absolute value since this represents outflow from godown
          godownItem.currentQuantityStrips += transaction.quantityStrips; // DB stores as negative
        }
      }

      // 2. Increase in MR stock (quantity_strips will be positive in DB for MR destination)
      if (transaction.locationTypeDestination == 'MR' && transaction.locationIdDestination != null) {
        // Only process if we're interested in this MR or all MRs or all locations
        final mrId = transaction.locationIdDestination!;
        if (locationFilter == 'ALL' ||
            locationFilter == 'MR' ||
            (locationFilter.startsWith('MR_') && locationFilter.replaceFirst('MR_', '') == mrId)) {
          final mrItem = _getOrCreateStockItem(
            transaction.productId,
            transaction.batchId,
            'MR',
            mrId,
            product,
            batch,
            stockMap,
            transaction.costPerStripAtTransaction,
          );
          // Use absolute value since this represents inflow to MR
          mrItem.currentQuantityStrips += transaction.quantityStrips.abs();
        }
      }

      // Skip the default processing since we've handled both sides
      return;
    } else if (txType == 'SALE_DIRECT_GODOWN') {
      // Sale directly from godown
      if (transaction.locationTypeSource == 'GODOWN') {
        stockLocation = 'GODOWN';
        stockLocationId = '';
      }
    } else if (txType == 'SALE_BY_MR') {
      // Sale by MR
      if (transaction.locationTypeSource == 'MR' && transaction.locationIdSource != null) {
        stockLocation = 'MR';
        stockLocationId = transaction.locationIdSource!;
      }
    } else if (txType.contains('RETURN_TO_GODOWN')) {
      // Return to godown (positive for godown, negative for source if MR)
      if (transaction.locationTypeDestination == 'GODOWN') {
        // Add to godown
        if (locationFilter == 'ALL' || locationFilter == 'GODOWN') {
          final godownItem = _getOrCreateStockItem(
            transaction.productId,
            transaction.batchId,
            'GODOWN',
            '',
            product,
            batch,
            stockMap,
            transaction.costPerStripAtTransaction,
          );
          // DB stores returns as positive for godown
          godownItem.currentQuantityStrips += transaction.quantityStrips;
        }
      }

      // Remove from MR if that's the source
      if (transaction.locationTypeSource == 'MR' && transaction.locationIdSource != null) {
        final mrId = transaction.locationIdSource!;
        if (locationFilter == 'ALL' ||
            locationFilter == 'MR' ||
            (locationFilter.startsWith('MR_') && locationFilter.replaceFirst('MR_', '') == mrId)) {
          final mrItem = _getOrCreateStockItem(
            transaction.productId,
            transaction.batchId,
            'MR',
            mrId,
            product,
            batch,
            stockMap,
            transaction.costPerStripAtTransaction,
          );
          // DB stores returns as negative for MR source
          mrItem.currentQuantityStrips += transaction.quantityStrips;
        }
      }

      // Skip default processing
      return;
    } else if (txType.contains('ADJUST_DAMAGE_') ||
        txType.contains('ADJUST_LOSS_') ||
        txType.contains('ADJUST_EXPIRED_')) {
      // Adjustments for damage/loss/expiry
      if (txType.contains('_GODOWN')) {
        stockLocation = 'GODOWN';
        stockLocationId = '';
      } else if (txType.contains('_MR') && transaction.locationIdSource != null) {
        stockLocation = 'MR';
        stockLocationId = transaction.locationIdSource!;
      }
    } else if (txType.contains('OPENING_STOCK_')) {
      // Opening stock
      if (txType.contains('OPENING_STOCK_GODOWN')) {
        stockLocation = 'GODOWN';
        stockLocationId = '';
      } else if (txType.contains('OPENING_STOCK_MR') && transaction.locationIdDestination != null) {
        stockLocation = 'MR';
        stockLocationId = transaction.locationIdDestination!;
      }
    } else if (txType.contains('REPLACEMENT_')) {
      // Handle replacements
      if (txType.contains('REPLACEMENT_FROM_GODOWN')) {
        // Outflow from godown
        if (locationFilter == 'ALL' || locationFilter == 'GODOWN') {
          final godownItem = _getOrCreateStockItem(
            transaction.productId,
            transaction.batchId,
            'GODOWN',
            '',
            product,
            batch,
            stockMap,
            transaction.costPerStripAtTransaction,
          );
          // DB stores replacements as negative for source
          godownItem.currentQuantityStrips += transaction.quantityStrips;
        }
      } else if (txType.contains('REPLACEMENT_FROM_MR') && transaction.locationIdSource != null) {
        // Outflow from MR
        final mrId = transaction.locationIdSource!;
        if (locationFilter == 'ALL' ||
            locationFilter == 'MR' ||
            (locationFilter.startsWith('MR_') && locationFilter.replaceFirst('MR_', '') == mrId)) {
          final mrItem = _getOrCreateStockItem(
            transaction.productId,
            transaction.batchId,
            'MR',
            mrId,
            product,
            batch,
            stockMap,
            transaction.costPerStripAtTransaction,
          );
          // DB stores replacements as negative for source
          mrItem.currentQuantityStrips += transaction.quantityStrips;
        }
      }

      // Skip default processing
      return;
    }

    // Apply the stock change if we determined a location
    if (stockLocation != null) {
      // Apply location filter
      if (stockLocation == 'GODOWN' && locationFilter != 'ALL' && locationFilter != 'GODOWN') {
        return;
      }

      if (stockLocation == 'MR') {
        if (locationFilter != 'ALL' &&
            locationFilter != 'MR' &&
            !(locationFilter.startsWith('MR_') && locationFilter.replaceFirst('MR_', '') == stockLocationId)) {
          return;
        }
      }

      final stockItem = _getOrCreateStockItem(
        transaction.productId,
        transaction.batchId,
        stockLocation,
        stockLocationId ?? '',
        product,
        batch,
        stockMap,
        transaction.costPerStripAtTransaction,
      );

      // Use the quantity_strips directly as DB already stores correct signs
      // Positive for incoming stocks, negative for outgoing stocks
      stockItem.currentQuantityStrips += transaction.quantityStrips;

      // Update cost per strip for positive transactions (inflows)
      if (transaction.quantityStrips > 0) {
        stockItem.costPerStrip = transaction.costPerStripAtTransaction;
      }
    }
  }

  /// Helper function to get or create a stock item entry
  static StockItem _getOrCreateStockItem(
    String productId,
    String batchId,
    String locationType,
    String locationId,
    Product product,
    Batch batch,
    Map<String, StockItem> stockMap,
    double costPerStrip,
  ) {
    final key = '${productId}_${batchId}_${locationType}_$locationId';

    if (!stockMap.containsKey(key)) {
      final categoryName = product.productCategories?.isNotEmpty == true
          ? product.productCategories!.first.categoryName
          : null;

      stockMap[key] = StockItem(
        productId: productId,
        productName: product.productName,
        productCode: product.productCode,
        genericName: product.genericName,
        batchId: batchId,
        batchNumber: batch.batchNumber,
        expiryDate: batch.expiryDate,
        locationType: locationType,
        locationId: locationId,
        currentQuantityStrips: 0,
        costPerStrip: costPerStrip,
        totalValue: 0,
        categoryName: categoryName,
        minStockLevelGodown: product.minStockLevelGodown,
        minStockLevelMr: product.minStockLevelMr,
      );
    }

    return stockMap[key]!;
  }

  /// Calculates summary statistics from stock data
  static StockSummary calculateStockSummary(List<StockItem> stockData) {
    if (stockData.isEmpty) {
      return StockSummary(
        totalProducts: 0,
        totalBatches: 0,
        totalValue: 0,
        lowStockItems: 0,
        expiringSoonItems: 0,
      );
    }

    final uniqueProducts = stockData.map((item) => item.productId).toSet();
    final uniqueBatches = stockData.map((item) => item.batchId).toSet();
    final totalValue = stockData.fold<double>(0, (sum, item) => sum + item.totalValue);

    // Calculate items with low stock
    final lowStockItems = stockData.where((item) {
      final minLevel = item.locationType == 'GODOWN'
          ? item.minStockLevelGodown ?? 0
          : item.minStockLevelMr ?? 0;
      return item.currentQuantityStrips <= minLevel;
    }).length;

    // Calculate items expiring in next 30 days
    final thirtyDaysFromNow = DateTime.now().add(const Duration(days: 30));
    final expiringSoonItems = stockData.where((item) {
      return item.expiryDate.isBefore(thirtyDaysFromNow) || item.expiryDate.isAtSameMomentAs(thirtyDaysFromNow);
    }).length;

    return StockSummary(
      totalProducts: uniqueProducts.length,
      totalBatches: uniqueBatches.length,
      totalValue: totalValue,
      lowStockItems: lowStockItems,
      expiringSoonItems: expiringSoonItems,
    );
  }

  /// Gets expiry status for a given expiry date
  static ExpiryStatus getExpiryStatus(String expiryDate) {
    final expiry = DateTime.parse(expiryDate);
    final today = DateTime.now();
    final thirtyDaysFromNow = today.add(const Duration(days: 30));

    if (expiry.isBefore(today)) {
      return ExpiryStatus.expired;
    } else if (expiry.isBefore(thirtyDaysFromNow) || expiry.isAtSameMomentAs(thirtyDaysFromNow)) {
      return ExpiryStatus.expiringSoon;
    } else {
      return ExpiryStatus.good;
    }
  }

  /// Gets stock status for a given stock item
  static StockStatus getStockStatus(StockItem item) {
    final minLevel = item.locationType == 'GODOWN'
        ? item.minStockLevelGodown ?? 0
        : item.minStockLevelMr ?? 0;

    if (item.currentQuantityStrips <= minLevel) {
      return StockStatus.low;
    } else if (item.currentQuantityStrips <= (minLevel * 1.5).round()) {
      return StockStatus.medium;
    } else {
      return StockStatus.good;
    }
  }

  /// Fetch categories for filter
  static Future<List<Map<String, dynamic>>> getCategories() async {
    final response = await _supabase
        .from('product_categories')
        .select('category_name')
        .eq('is_active', true);
    return List<Map<String, dynamic>>.from(response);
  }

  /// Fetch MR users for location filter
  static Future<List<Map<String, dynamic>>> getMrUsers() async {
    final response = await _supabase
        .from('profiles')
        .select('user_id, name')
        .eq('role', 'user');
    return List<Map<String, dynamic>>.from(response);
  }

  /// Group stock data by product
  static List<GroupedStockItem> groupStockData(List<StockItem> stockData) {
    final grouped = <String, GroupedStockItem>{};

    for (final item in stockData) {
      final key = item.productId;
      if (!grouped.containsKey(key)) {
        grouped[key] = GroupedStockItem(
          productId: item.productId,
          productName: item.productName,
          productCode: item.productCode,
          genericName: item.genericName,
          categoryName: item.categoryName,
          totalQuantityStrips: 0,
          totalValue: 0,
          batchCount: 0,
          batches: [],
          minStockLevelGodown: item.minStockLevelGodown,
          minStockLevelMr: item.minStockLevelMr,
        );
      }

      final groupedItem = grouped[key]!;
      grouped[key] = GroupedStockItem(
        productId: groupedItem.productId,
        productName: groupedItem.productName,
        productCode: groupedItem.productCode,
        genericName: groupedItem.genericName,
        categoryName: groupedItem.categoryName,
        totalQuantityStrips: groupedItem.totalQuantityStrips + item.currentQuantityStrips,
        totalValue: groupedItem.totalValue + item.totalValue,
        batchCount: groupedItem.batchCount + 1,
        batches: [...groupedItem.batches, item],
        minStockLevelGodown: groupedItem.minStockLevelGodown,
        minStockLevelMr: groupedItem.minStockLevelMr,
      );
    }

    return grouped.values.toList();
  }
}